\section{Language Transforms\timeestimation{25h}} % (fold)
\label{sec:transforms}
In this chapter, we'll discuss how we can use the notion of a data 
representation of a program to get a standard toolchain.
\subsection{Language Subsets} % (fold)
\label{sub:Language Subsets}
\paragraph{{\tt C++}  and {\tt C} } % (fold)
\label{par:Cpp and C}
\begin{defn}
	Let {\tt A} and {\tt B} be two languages such that each valid {\tt B} 
	program is also a valid {\tt A} program. Further 
	$\forall b\in B\forall d\in Dat(B): \interpret{b}_A(d) =
	\interpret{b}_B(d)$
\end{defn}

% paragraph Cpp and C (end)
% subsection Language Subsets (end)
\subsection{Interpreter} % (fold)
\label{sub:Interpreter}

% subsection Interpreter (end)
\subsection{Compiler} % (fold)
\label{sub:Compiler}
\paragraph{How the {\tt gcc} is ported} % (fold)
\label{par:gcc}
\lineofthought{ Bootstrapping von {\tt gcc} }
% paragraph Wie der gcc portiert wird (end)

% subsection Compiler (end)
\subsection{Futamura Projections} % (fold)
\label{sub:Futamura}
\subsubsection{Specializer} % (fold)
\label{ssub:Specializer}
\subsubsection{Futamura Projections} % (fold)
\label{ssub:Futamura Projections}
The notion of a specializer as a transformer of source code has lead to some 
interesting observations: \lineofthought{ 
	\begin{itemize}
		\item An interpreter spec'ed with source is executable ($\rightarrow$ py2exe)
		\item A compiler is a specialized specializer with the step above.
		\item Repeat to get a compiler generator.
	\end{itemize} 
	Use types to visualize (
	$\applied{spec}: Input_1 \rightarrow \coded{\left( Input_2 \rightarrow Output \right)}$)
}

% subsubsection Futamura Projections (end)
\paragraph{The PyPy project} % (fold)
\label{par:The PyPy project}
\begin{example}
\lineofthought{Research how PyPy uses specializers and how that does
	compare to the Futamura Projections. \cite{psycho}}
\end{example}

% paragraph The PyPy project (end)

% subsubsection Specializer (end)
% subsection Futamura (end)
