Computability and complexity are in some way the basics of what computer
science is about. Where algorithmics might answer what the currently best known
solution to a problem is, computability theory says if a solution can exist and
complexity theory gives the problem (not the concrete algorithm!) a general
assessment of its difficulty, i.e. no algorithm can solve the problem faster 
than its inert complexity.

For this, one needs an idea what a problem is, and when it is solvable. A 
problem can be understood as getting some kind of input data $x\in \Input[A]$ 
and needing to produce an output value $y\in \Output[A]$, in other words: 
computing a function $f:\Input[A] \rightarrow \Output[A]$\footnote{Equivalently, 
a problem can be characterized as deciding if $x\in^? B$.}.

A problem is then considered solvable, if there is in some way a solution to 
it, but what a solution looks like, divides the minds: 

\paragraph{Turing and his machines}
Turing's approach is a very mechanical one: A machine that has memory in the 
form of an arbitrarily large tape and is in a certain state. Depending on the 
tape's content at the current position and the current state, it can write to 
the tape, change its state and move one cell to the left or to the right.

\paragraph{Kleene composes functions}
Kleene held it intuitively computable that there are some simple functions 
such as the projections, the constant functions, and the successor are 
computable and that the composition of two computable functions is again 
computable. Finally every function can be coded and the codes can then be executed.

\paragraph{Markov rewrites strings}
Markov noted that executing an algorithm is basically nothing but rewriting a 
string (the memory) according to some predefined rules.

\paragraph{Programing languages}
While each of these approaches is interesting in their own right, they do not 
reflect the intuitions of a modern computer scientist, who already knows 
about programming languages and is closer to them then to building machines 
or even mathematical constructs.

Nearly all modern languages try to capture the full spectrum of solvable 
problems. For the purposes of this text, the \WHILE language will 
serve as a minimal coding for computability.

\subsection{What is a programming language?} % (fold)
\label{sub:What is a programming language}
We have an intuitive notion of what a programming language is, which probably
goes like "A language, in which programs can be written" or "An executable
language". But what makes a string of letters executable? 

The difference is just that we know how a programming language should be 
interpreted, i.e.\ a program can be mapped to a function and thus in the 
realm of mathematics.

\begin{defn}
	A partial function from $A$ to $B$ is a function 
	\[ f:A\rightarrow B_\bot = B\cup \{\bot\}\]
	where $\bot$ signifies that no value exists for that input.

	For example $\interpret{A}(x) = \bot$ means, that the program $A$ does 
	either give an error or does not terminate on the input $x$.
\end{defn}

\begin{defn}
	A {\em semantic function} $\interpret[A]{.}$ for a programming language $A$ is a function
	\[ \interpret[A]{.}: A \rightarrow \left( \Input[A] \rightarrow 
	\Output[A]\cup \{\bot\}\right)\]
	where $\bot$ signifies either an error or that the function does not return.
	Then the function $\interpret[A]{.}$ takes a valid $A$ program and 
	gives a function that maps inputs for $A$ programs to outputs (if any).
\end{defn}
The semantic function defines what a program {\em means}, while its syntax 
defines {\em how it should look like}. It typically uses other functions to 
denote parts of the program. 
\begin{example}
	As a part of a programming language, we want to know the semantics of 
	$\mathtt{572}$. Note that $\mathtt{572}$ is a string, not the number. However 
	$\interpret[dec]{\mathtt{572}}=5\cdot 100+7\cdot 10+ 2$ {\em is} the number, not the string. 
\end{example}

When describing a programming language, the terms {\em expression} and {\em
statement} will be used often. An {\em expression} is a representation of 
data used in the language. It returns a value and can depend on the state of 
the computation, e.g. to evaluate variables. Some expressions even change the 
state of the computation. A {\em statement} does not return a value and just 
changes the state.
\begin{example}
	In the assignment in a {\tt C}-like language {\tt int four = 2+2;}, the 
	whole line is a statement since it introduces a new variable name, that 
	can be referenced. {\tt 2+2} is an expression that returns $4$. After this 
	line, {\tt four} is an expression as well and will return the current value 
	of the variable.
\end{example}

% subsection What is a programming language (end)
