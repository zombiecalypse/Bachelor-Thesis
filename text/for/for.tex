\section{The {\tt FOR} language}
\label{sec:FOR}
\begin{table}[htb]
	\begin{grammar}
		<expression> ::= 
							`nil' 
				\alt 	`cons' <expression> <expression>
				\alt 	`hd' <expression>
				\alt 	`tl' <expression>
				\alt 	<variable>

		<statement-list> ::= <statement> \alt <statement> newline <statement-list>

		<block> ::= `{' <statement-list> `}'

		<statement> ::=
							<variable> `:=' <expression>
				\alt	`if' <expression> <block> <else-block>
				\alt	`for' <variable> `in' <expression> <block>
			
				<else-block> ::= <empty> \alt `else' <block>
				
				<program> ::= <name> `read' <variable> <block> `write' <variable>
	\end{grammar}
	\caption{The \FOR syntax \label{tab:FOR-syntax}}
\end{table}

\subsection{The Elements} % (fold)
\label{sub:The Elements}
The \FOR language contains only very basic commands, but they can be combined
to implement a huge number of algorithms. As the data structure, we choose 
the humble {\tt cons} cell, that contains only a reference as the head and 
another as the tail.\footnote{An observant reader will notice that this
structure stems from the building of linked lists.}
.
\begin{figure}[htb]
	\begin{center}
		\includegraphics[height=3cm]{for/images/conscell}
	\end{center}
	\caption{The {\tt cons} cell}
\end{figure}

The expression {\tt cons e1 e2} constructs such a cell with the evaluation of
e1 in the head and the evaluation of e2 in the tail. The expression {\tt hd e1}
yields the head of the evaluation of e1 and {\tt tl e1} its tail. Since all our
current constructs need another expression, we also need a "bottom" to this
regress. We add {\tt nil} as an expression, which is distinct from any {\tt
cons e f}. We also want to refer to stored values, so an identifier (eg {\tt
X}) can also be an expression.

There are very few types of statements in \FOR, just three to be precise. The 
first is the {\em assignment} {\tt X := e}, which assigns the variable {\tt X}
the evaluation of {\tt e}. Later, when {\tt X} is used in an expression, it 
will reproduce this value. The second is the classic {\tt if} statement, that 
only executes its first block, if the expression does {\em not} return {\tt nil} 
and the else-block -- if any -- otherwise. Finally, there is the eponymous 
{\tt for} loop, that works as follows:

\begin{enumerate}
	\item On first entering the loop, the expression is evaluated and lets call 
		it $e$.
	\item If the evaluation is {\tt nil}, the loop is not evaluated anymore.
	\item Otherwise the block is evaluated with the value of the head of $e$.
	\item Then this procedure is run again with the tail of $e$.
\end{enumerate}

\subsection{\FOR computability}
The probably most important property of the \FOR language is that programs in 
it always terminate. The reason for this is, that upon entering the for loop, 
the number of repetitions is fixed as the length of the evaluated expression. 
Since we can't build an infinite expression in the finite time before the 
loop, the program terminates.

When experimenting with the language, one quickly finds, that many important 
functions are \FOR computable:

\begin{itemize}
	\item Constant functions.
	\item Addition.
	\item Multiplication -- as repeated addition.
	\item Exponentiation -- as repeated multiplication.
	\item Unary/binary conversion.
	\item Testing if a given number is prime.
	\item ...
\end{itemize}

As we can see, it is relatively simple to generate huge numbers using the 
\FOR language and then generate lists with that length.

\lineofthought{Thm: Algorithm $C$ with $T(C)\in O(f(n))$, $f(n) \in \FOR$, 
	then $\interpret{C}\in \FOR$}

At first glance it seems that any function can be computed this way, but 
sadly, that is not the case.

\begin{theorem}
Intuitively the interpretation of a \FOR program should be computable. We can 
do it in an algorithmic way and so it is only reasonable to expect \FOR to be 
able to interpret itself. As we will see, that can not be the case:

Assume, there was a procedure in \FOR $exec$ that takes $(program.input)$ as 
its argument. Now the following procedure would surely be a \FOR program too:

\begin{verbatim}
inverse read X {
  result := [exec](X)
  if result {
    Y := FALSE
  } else {
  Y := TRUE
  }
} write Y
\end{verbatim}

We have 
\[ \interpret{inverse}(program.input) = \begin{cases}
		\mathtt{TRUE}, &\text{ if }\interpret{program}(input) = \mathtt{FALSE} \\
		\mathtt{FALSE}, &\text{ otherwise }
	\end{cases} \]

It outputs {\tt TRUE} iff the given program outputs {\tt FALSE}. What then 
is $\interpret{inverse}(inverse.inverse)$? Assume first that it is 
{\tt TRUE}, then by definition it is {\tt FALSE} -- and vice versa! So it 
neither returns {\tt TRUE} {\em nor} {\tt FALSE}. The only way that would 
work would be if it didn't return anything at all, but as we have seen, all 
\FOR programs terminate in finite time, so that can not be the case. 
Therefore {\tt inverse} can not be a \FOR program and by extension {\tt exec} 
is not a \FOR program.
\end{theorem}


This is unfortunate, not only because we have seen that there are functions 
that are not \FOR computable, but that in general, any language that 

\lineofthought{
	\begin{itemize}
		\item number of steps computable $\rightarrow$ function that takes this 
			may steps is computable.
	\end{itemize}
}
\subsection{Non-\FOR computability}
\lineofthought{
	\begin{itemize}
		\item Ackermann
		\item Self-interpretation
	\end{itemize}
}
